using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using PLang.Building.Model;
using PLang.Building.Parsers;
using PLang.Errors.Builder;
using PLang.Interfaces;
using PLang.Runtime;
using PLang.Services.CompilerService;
using PLang.Utils;
using PLang.Utils.Extractors;

namespace PLang.Modules.CodeModule
{
	public class Builder : BaseBuilder
	{

		private readonly IPLangFileSystem fileSystem;
		private readonly PrParser prParser;
		private readonly ILogger logger;
		private readonly ProgramFactory programFactory;
		private int errorCount = 0;

		public Builder(IPLangFileSystem fileSystem, PrParser prParser, ILogger logger, ProgramFactory programFactory) : base()
		{
			this.fileSystem = fileSystem;
			this.prParser = prParser;
			this.logger = logger;
			this.programFactory = programFactory;
		}


		public override async Task<(Instruction?, IBuilderError?)> Build(GoalStep step, IBuilderError? previousBuildError = null)
		{
			return await Build(step, null);
		}


		public async Task<(Instruction?, IBuilderError?)> Build(GoalStep step, CompilerError? error = null, int errorCount = 0)
		{
			var result = await PrepareStep(step);
			if (result.Instruction != null || result.Error != null) return result;

			return await MakeCode(step, error, errorCount);

		}
		public async Task<(Instruction? Instruction, IBuilderError? Error)> PrepareStep(GoalStep step)
		{
			var file = programFactory.GetProgram<FileModule.Program>(step);
			var files = await file.GetFilePathsInDirectory(step.Goal.RelativeGoalFolderPath, "*.cs", includeSubfolders: true);
			if (files.Count == 0) return (null, null);

			SetSystem(@$"You have two options:

Generate New Code: Use the user input to create a new code snippet. The user will provide a description of the execution, and the code generation will be completed in another request. If this option is chosen, FileName should be null.

Use a Prepared File: Utilize a <prepared> .cs file. The user will define the file to run, e.g., ""run CSharpFile with %content% write to %value%"". This example is applicable if the .cs file takes in one parameter and returns a value.

Note: Prioritize generating new code unless the task explicitly requires using a prepared file.

<prepared>
{string.Join("\n", files.Select(p => p.Path))}
<prepared>

return file name with path or null");
			(var instruction, var buildError) = await Build<FileToUse>(step);
			if (buildError != null) return (null, buildError);

			var fileToUse = instruction!.Function as FileToUse;
			if (fileToUse.NameOfCSharpFile == null) return (null, null);

			var result = await file.ReadTextFile(fileToUse.NameOfCSharpFile);
			if (result.Error != null) return (null, new StepBuilderError(result.Error, step));

			string source = result.Item1 as string;

			var tree = CSharpSyntaxTree.ParseText(source);
			var root = tree.GetCompilationUnitRoot();

			var defaultClassName = "PLang" + fileSystem.Path.GetFileNameWithoutExtension(fileToUse.NameOfCSharpFile);
			var dirPath = fileSystem.Path.GetDirectoryName(fileToUse.NameOfCSharpFile) ?? fileSystem.Path.GetFileNameWithoutExtension(fileToUse.NameOfCSharpFile);
			var defaultNamespace = ("PLang.AutoGenerated." + dirPath.AdjustPathToOs().Replace(Path.DirectorySeparatorChar, '.').TrimStart('.')).TrimEnd('.');

			// namespace
			var nsDecl = root
				.DescendantNodes()
				.OfType<NamespaceDeclarationSyntax>()
				.FirstOrDefault();
			var @namespace = nsDecl?.Name.ToString() ?? null;

			// class name
			var classDecl = root
				.DescendantNodes()
				.OfType<ClassDeclarationSyntax>()
				.FirstOrDefault();
			var className = classDecl?.Identifier.Text ?? null;

			// usings
			var usings = root.Usings
				.Select(u => u.Name.ToString())
				.ToArray();

			string[]? inputParameters;
			string[]? outParameters;
			string methodName = null;
			if (classDecl != null)
			{
				// pick first method
				var method = classDecl
					.DescendantNodes()
					.OfType<MethodDeclarationSyntax>()
					.FirstOrDefault();

				if (method == null) return (null, new StepBuilderError("Method could not be found in .cs file", step));

				methodName = method.Identifier.ToString();

				inputParameters = method.ParameterList.Parameters
					.Select(p => p.ToString())
					.ToArray();
				outParameters = new[] { method.ReturnType.ToString() };
			}
			else
			{
				var decNodes = root.DescendantNodes();
				var ofType = decNodes.OfType<GlobalStatementSyntax>();
				var select = ofType.Select(gs => gs.Statement);
				var function = select.OfType<LocalFunctionStatementSyntax>().FirstOrDefault();

				string appendPublic = "";
				if (function.Modifiers.Count == 0)
				{
					appendPublic = "public ";
				}
				if (function.Modifiers.ToString() != "" && function.Modifiers.ToString() != "public")
				{
					return (null, new CompilerError("First method cannot be private or protected", "", step));
				}

				source = source.Insert(function.SpanStart, $"public class {defaultClassName} {{\n{appendPublic}");
				source += "\n}";

				className = defaultClassName;
				methodName = function.Identifier.ToString();

				inputParameters = function.ParameterList.Parameters
					.Select(p => p.ToString())
					.ToArray();
				outParameters = new[] { function.ReturnType.ToString() };
			}

			SetSystem(@$"You job is to map which %variable% in user input maps to <input_parameters> and which to <output_parameters> if it applies

<input_parameters> are parameters of a c# method
<output_parameters> is the return value of the method

<input_parameters>
{JsonConvert.SerializeObject(inputParameters)}
<input_parameters>

<output_parameters>
{JsonConvert.SerializeObject(outParameters)}
<output_parameters>

<example>
user: run c# Parse %text%, write to %parseText%

when <input_parameters> parameter is 'string content', then Inputs: {{ ""content"": ""%text%"" }}
when <output_parameters> parameter is 'System.String', then Outputs: {{ ""System.String"": ""%parseText%"" }}

This would map the user statement to the parameter 'content' of the code and have a string return value
<example>
");
			var hasher = programFactory.GetProgram<CryptographicModule.Program>(step);
			var hashResult = await hasher.GetHashOfFile(fileToUse.NameOfCSharpFile);
			if (hashResult.Error != null) return (null, new BuilderError(hashResult.Error));

			var buildResult = await Build<CodeParameters>(step);
			if (buildResult.BuilderError != null) return buildResult;

			var codeParams = buildResult.Instruction.Function as CodeParameters;

			if (@namespace == null)
			{
				source = $"namespace {defaultNamespace};\n\n{source}";
				@namespace = defaultNamespace;
			}

			var c = new FileCodeImplementationResponse(fileToUse.Reasoning, fileToUse.Name,
				fileToUse.NameOfCSharpFile,
				hashResult.Hash,
				source,
				@namespace,
				className,
				methodName,
				Parameters: codeParams.Parameters,
				ReturnValues: codeParams.ReturnValues
			);


			var compiler = new CSharpCompiler(fileSystem, prParser, logger);
			var dllName = compiler.GetPreviousBuildDllNamesToExclude(step);

			var error = await compiler.BuildFile(c, step, memoryStack);
			if (error != null) return (null, error);

			List<Parameter> parameters = new List<Parameter>();
			parameters.Add(new Parameter(c.GetType().FullName, "implementation", c));

			List<ReturnValue> returnValues = new List<ReturnValue>();
			foreach (var rv in codeParams.ReturnValues)
			{
				returnValues.Add(new ReturnValue(rv.Type, rv.VariableName));
			}

			var gf = new GenericFunction("No explaination", "RunFileCode", parameters, returnValues);

			var newInstruction = InstructionCreator.Create(gf, step, instruction.LlmRequest);
			return (newInstruction, null);
		}

		public record FileToUse(string Reasoning, string Name, List<Parameter>? Parameters = null, List<ReturnValue>? ReturnValues = null, string? NameOfCSharpFile = null) : IGenericFunction
		{
			public Instruction Instruction { get; set; }
		}

		public record CodeParameters(string Reasoning, string Name, List<Parameter> Parameters, List<ReturnValue> ReturnValues) : IGenericFunction
		{
			public Instruction Instruction { get; set; }
		}

		public record FileCodeImplementationResponse(string Reasoning, string Name, string FileName, string Hash, string SourceCode, string Namespace, string ClassName, string MethodName, List<Parameter> Parameters, List<ReturnValue> ReturnValues) : IGenericFunction
		{
			public Instruction Instruction { get; set; }
		}

		public async Task<(Instruction?, IBuilderError?)> MakeCode(GoalStep step, CompilerError? error = null, int errorCount = 0)
		{
			if (errorCount++ > 3)
			{
				return (null, error ?? new StepBuilderError("Could not compile code for this step", step));
			}


			var compiler = new CSharpCompiler(fileSystem, prParser, logger);
			var dllName = compiler.GetPreviousBuildDllNamesToExclude(step);

			//TODO: Any file access should have IPLangFileSystem fileSystem injected and use it as fileSystem.File... or fileSystem.Directory....
			SetSystem(@$"Act as a senior C# developer, that converts the user statement into a C#(Version. 9) code. 

## Rules ##
- Generate static class. The code generated should have 1 method with the static method named ExecutePlangCode. 
- A variable in user intent is defined by starting and ending %.
- Variables defined in the user intent can be passed into the ExecutePlangCode function by value, but only if defined by user. 
- Variable names passed to ExecutePlangCode function MUST be unmodified from the user statement
- The code will not be modified after you generate it.
- If condition fails, throw Exception, unless defined otherwise by user command
- Exception message should be for non-technical user
- ALWAYS use long or long? instead of int or int?
- Use long.TryParse When validating if variable is long
- Do not reference any DTO classes. Choose the type that seems to fit best when not defined by user input. Use dynamic? if complex object is needed.
- Strings are defined with double quote ("")
- Any class from System.IO, should be replaced with PLang.SafeFileSystem.PLangFileSystem. It contains same classes and methods. 
- If PLangFileSystem is needed, add parameter PLang.SafeFileSystem.PLangFileSystem fileSystem into ExecutePlangCode method, but ONLY if needed. Assembly for PLangFileSystem is already include, do not list it in Assemblies response.
- System.IO.Path needs to be mapped to PLang.SafeFileSystem.Path which DOES not contain static methods, e.g. Path.GetFileName => fileSystem.Path.GetFileName. fileSystem IS provided as parameter as part of ExecutePlangCode method 
- When condition is checking if variable is null, the variable needs to be defined with ? in the parameter, e.g. ExecutePlangCode(dynamic? variable)
- Variables that are injected into ExecutePlangCode method and contain dot(.), then replace dot(.) with the letter α in the parameter list. e.g. %user.id% to userαid, %product.items[0].title% to productαitemsα0ααtitle, %list[1]% to listα1α
- Keep underscore in variables if defined by user, e.g.  if %data.user_id%(string) is null => ExecutePlangCode(string? dataαuser_id)
- Consider top security measures when generating code and validate code
- When checking type and converting variables to type, use Convert.ChangeType method
- When user defines assembly or using, include them in your answer
- append @ sign for reserved variable in C#
- on error in step is handled by external system, DO NOT generate code for it
- follow user instruction when generating code
## Rules ##

## Response information ##
- Namespace: MUST be PLangGeneratedCode
- Name: is name of class, it should represent the intent of what the code is doing. 
{dllName}
- Using: must include namespaces that are needed to compile code.
- Assemblies: dll to reference to compile using Roslyn
- Parameters: Parameters MUST match parameter count sent to ExecutePlangCode.
- PLang.Modules.BaseBuilder+Parameter has scheme => {{ Name:string, Value:string, Type:string }} Name is the name of the parameter in the ExecutePlangCode method, Value is the %variable% name that matches and Type is .net object type
- ReturnValues: keep as is defined by user, e.g. user: 'is leap year, write ""yes"" to %answer% => ReturnValues would be [""%answer%""], only return 1 value
## Response information ##
");

			AppendToAssistantCommand($@"




## examples ##
replace ""<strong>"" with """" from %html%, write to %html% => string ExecutePlangCode(string? html) {{
    //validate input parameter 
    html = html.Replace(""<strong>"", """");
	return html;
}}
Parameters: [{{Name:""html"", Value:""%html%"", Type:""string""}}]
ReturnValue: [""type"":""System.String"", VariableName:""%html%""]

%list.Count%*50, write to %result% => long ExecutePlangCode(long? listαCount) {{
    //validate input parameter 
    result = listαCount*50;
	return result;
}}
Parameters: [{{Name:""listαCount"", Value:""%list.Count%"", Type:""long""}}]
ReturnValues: [""type"":""System.Int64"", VariableName:""%result%""]

%response.data.total%*%response.data.total_amount%, write to %allTotal%, => long ExecutePlangCode(dynamic? response.data.total, dynamic? response.data.total_amount) {{ 
    //validate input parameter 
	long allTotal = response.data.total*response.data.total_amount;
	return allTotal;
}}
Parameters: [{{Name:""response.data.total"", Value:""%response.data.total%"", Type:""dynamic""}}, Name:""response.data.total_amount"", Value:""%response.data.total_amount%"", Type:""dynamic""}}]
ReturnValues: [""type"":""List<object>"", VariableName:""%allTotal%""]


get filename of %filePath%, write to %fileName% => string ExecutePlangCode(IPlangFileSystem fileSystem, string filePath) {{
	//validate input parameter 
	fileName = fileSystem.Path.GetFileName(filePath);
	return fileName;
}}
Parameters: [{{Name:""fileSystem"", Value:""%filePath%"", Type:""string""}}]
ReturnValues: [""type"":""System.String"", VariableName:""%fileName%""]
## examples ##");

			if (error != null)
			{
				//AppendToAssistantCommand(error.LlmInstruction);
			}

			step.LlmRequest.llmResponseType = "csharp";

			(var instruction, var buildError) = await Build<CodeImplementationResponse>(step, error);
			if (buildError != null) return (null, buildError);

			if (instruction == null)
			{
				return (null, new StepBuilderError("Could not create instruction file", step));
			}

			var answer = (CodeImplementationResponse)instruction.Function;

			(var implementation, var compilerError) = await compiler.BuildCode<CodeImplementationResponse>(answer, step, memoryStack);
			if (compilerError != null)
			{
				logger.LogWarning($"- Error compiling code - will ask LLM again - Error:{compilerError} - Code:{compilerError.LlmInstruction}");
				return await MakeCode(step, compilerError, errorCount);
			}


			List<Parameter> parameters = new List<Parameter>();
			parameters.Add(new Parameter(implementation.GetType().FullName, "implementation", implementation));

			List<ReturnValue> returnValues = new List<ReturnValue>();
			if (implementation.ReturnValues != null)
			{
				foreach (var rv in implementation.ReturnValues)
				{
					returnValues.Add(new ReturnValue(rv.Type, rv.VariableName));
				}
			}

			var gf = new GenericFunction(implementation.Reasoning, "RunInlineCode", parameters, returnValues);


			var newInstruction = InstructionCreator.Create(gf, step, instruction.LlmRequest);
			return (newInstruction, null);


		}

		public async Task<IBuilderError?> BuilderRun(GenericFunction gf, GoalStep step)
		{
			int i =0 ;

			return null;
		}


	}





}

